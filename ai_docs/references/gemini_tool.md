Simplified prompt of how you can use Gemini for planning and Claude Code, or Cursor for execution:  /planwithgemini Generate a projectâ€wide implementation or refactor plan with Google Gemini CLI, using Codefetch for smart context selection, then continue execution in Claude Code. IMPORTANT NOTE: These prompts work with Gemini and can be used as Claude Code slash commands (in .claude/commands/planwithgemini) or as Cursor rules. However, I recommend referencing them with "@" for more reliable execution, as rules can sometimes behave unpredictably. (Thats the reason why ) Prompts (or when used as claude slash commands) * /planwithgemini-plan-auto-context - Analyzes your codebase and selects only relevant files/folders for your request * /planwithgemini-plan - Uses entire codebase context (simpler but less efficient) Both generate a plan file without writing code. Quickâ€Start âš ï¸ Add codefetch/ to your .gitignore file to avoid committing the fetched codebase. Install Gemini CLI   # 1 Install Gemini CLI & Codefetch (once) npm install -g @google/gemini-cli  # 2 Authenticate Gemini (once) gemini            # or: export GEMINI_API_KEY=...   Note: Use Gemini CLI for free by logging in with a personal Google account to get a free Gemini Code Assist license. This gives you access to Gemini 2.5 Pro with a 1M token context window. The free tier includes 60 requests/minute and 1,000 requests/day. Learn more about Gemini CLI. Full Install instructions Install Claude Code   # 1 Install Claude Code  npm install -g @anthropic-ai/claude-code  # 2a Run Claude Code claude  # 2b Yolo Mode claude --dangerously-skip-permissions   Full Install instructions Install Codefetch (Optional)   npm install -g codefetch@latest   --- allowed-tools: Bash(git ls-files:), Bash(npx codefetch:), Bash(gemini:) description: Draft a highâ€level implementation/refactor plan â€“ first derive the optimal Codefetch context from the Git file list, then query Gemini CLI and hand the result back to Claude. Do NOT begin writing or changing application code. --- CRITICAL RULES: Dont plan or code anything!! Follow steps: The list below contains every tracked or untracked source file except those ignored by .gitignore, or Gitâ€™s default excludes. Claude should use this list to decide which folders/files matters. !git ls-files --cached --others --exclude-standard 1. Analyse the file inventory: and the userâ€™s request ($ARGUMENTS).   2. Choose the minimal yet sufficient context:    - Which topâ€level dirs (--include-dir) or specific files (--include-files) must be included?      - info: The --include-dir option uses the splitValues() function which: Takes comma-separated values    - Which heavy/irrelevant dirs (--exclude-dir) can be skipped?      - Feel free to limit by extension (-e .js,.ts, etc.) if appropriate.    You can also add a project tree with -t [depth] (e.g., -t 3); choose a depth that makes sense.   3. Explain your selection briefly: (one short paragraph).   4. Run Codefetch with your chosen flags. !npx -y codefetch@latest  -o "context.md" 5. Call Gemini CLI (allowed tool) with the prepared context: !gemini -p "@codefetch/context.md$ARGUMENTS analyze the  and, in line with the , deliver a detailed, full step-by-step implementation plan for my development team." > plans/-plan-.md  --- allowed-tools: Bash(npx -y codefetch:), Bash(gemini:*) description: Draft a highâ€level implementation/refactor plan â€“ first derive the optimal Codefetch context from the Git file list, then query Gemini CLI and hand the result back to Claude. Do NOT begin writing or changing application code. --- CRITICAL RULES: Dont plan or code anything!! Follow steps: 1. Call Codefetch !npx -y codefetch@latest -o "context.md" 2. Call Gemini CLI (allowed tool) with the prepared context: !gemini -p "@codefetch/context.md$ARGUMENTS analyze the  and, in line with the , deliver a detailed, full step-by-step implementation plan for my development team." > plans/-plan-.md  claude-code-ntfy A transparent wrapper for Claude Code that sends a notification when Claude needs your attention. Features * ğŸ”” Single notification when Claude needs attention * ğŸ”„ Transparent wrapping - preserves all Claude Code functionality * ğŸ’¤ Intelligent inactivity detection * ğŸ–¥ï¸ Cross-platform support (Linux/macOS) Intelligent Inactivity Detection The backstop timer provides smart notifications when Claude might need your attention: * While Claude is outputting: Timer is continuously reset * When Claude stops: A 30-second countdown begins * If you start typing: Timer is permanently disabled * If Claude sent a bell: Timer is disabled (you're already notified) * After 30 seconds of inactivity: ONE notification is sent This ensures you're notified when Claude needs input, but not when you're actively working.  Ask Claude to present you different options when solving a problem and you'll get vastly better results. As a developer you understand tradeoffs better than the agent. I usually ask for 3 options, but if you leave out the number it'll give you a variable amount based on what it can think of. If you don't like any of them, push further.